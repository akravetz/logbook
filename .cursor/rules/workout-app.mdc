---
description:
globs:
alwaysApply: true
---
# Workout App Project Rules

## Project Context
Building a workout tracking web app with backend-first approach using Python, FastAPI, and PostgreSQL. Frontend will follow using TypeScript, Next.js 14, and ShadCN UI.

## Key Project Decisions

### Technology Stack
- **Backend**: Python 3.12+ + FastAPI + SQLAlchemy 2.0 + PostgreSQL
- **Testing**: pytest + testcontainers + transaction isolation
- **Development**: uv + Atlas + ruff + pre-commit + gitleaks
- **Frontend** (Future): TypeScript + Next.js 14 + ShadCN UI + Tailwind CSS
- **Auth**: Google OAuth2 with JWT tokens

### Business Rules
1. Each exercise can only appear once per workout
2. Exercise order matters (use exercise_order field)
3. System exercises (is_user_created=false) are read-only
4. Set IDs are autogenerated - never include in PUT requests
5. All weights in pounds (float)
6. All timestamps in UTC

### Backend Architecture
- **Functional Cohesion**: Organize by domain (auth/, exercises/, workouts/)
- **Repository Pattern**: All database operations in repository classes
- **Service Layer**: Business logic separate from data access
- **Dependency Injection**: Use FastAPI's Depends system
- **Async Everywhere**: All database operations must be async

### API Patterns
- Nested resources: `/workouts/{id}/exercise-executions/{exerciseId}`
- No general workout PATCH - only specific operations
- PUT for full replacement (exercise executions)
- Consistent error responses with type field
- Pagination on all list endpoints

### Database Patterns
```python
# Use SQLAlchemy 2.0 syntax
class Exercise(BaseModel):
    __tablename__ = "exercises"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(255), nullable=False)

# Transaction pattern
async with session.begin():
    # Operations auto-commit on success
    # Auto-rollback on exception
```

### Testing Patterns
```python
# Transaction isolation for tests
@pytest.fixture
async def session(db_engine):
    async with db_engine.begin() as conn:
        async with async_session_maker(bind=conn) as session:
            yield session
            await session.rollback()

# Use same session in API and tests
app.dependency_overrides[get_session] = lambda: session
```

### Development Workflow
```bash
task dev       # Run development server
task test      # Run all tests
task lint      # Run linting
task migrate   # Run migrations
```

### Code Style Preferences
- Use Pydantic for all API validation
- Keep business logic in service layer
- Repository methods should be simple queries
- Use type hints everywhere
- Descriptive variable names over comments

### Current State (as of last update)
- Backend design complete (see docs/backend_design.md)
- Ready to implement backend API
- Using backend-first approach
- Frontend development will follow after API is stable

### Common Patterns to Follow
```python
# Repository pattern
class ExerciseRepository:
    async def search(self, query: str) -> list[Exercise]:
        stmt = select(Exercise).where(
            Exercise.name.ilike(f"%{query}%")
        )
        result = await self.session.execute(stmt)
        return result.scalars().all()

# Service pattern
class ExerciseService:
    async def create_exercise(
        self,
        user_id: int,
        data: ExerciseCreate
    ) -> Exercise:
        # Business validation here
        return await self.repo.create(data)

# Router pattern
@router.get("/exercises")
async def list_exercises(
    service: ExerciseService = Depends(get_exercise_service),
    filters: ExerciseFilters = Depends(),
):
    return await service.list_exercises(filters)
```

### Things to Avoid
- Don't use sync database operations (always async)
- Don't put business logic in routers
- Don't skip transaction management
- Don't use mutable default arguments
- Don't commit secrets (pre-commit prevents this)
- Don't create workout templates yet (deferred)
- Don't edit `pyproject.toml` directly to add dependencies, always use uv commands `uv add` etc

### Security First
- All endpoints require authentication (except auth endpoints)
- Use dependency injection for current user
- Validate user owns resources before operations
- Environment variables for all secrets
- Pre-commit hooks catch security issues

### Performance Guidelines
- Use selectinload for eager loading when needed
- Implement pagination on all list endpoints
- Connection pooling configured in engine
- Avoid N+1 queries with proper joins
- Index foreign keys and search fields

## Authentication Architecture (Latest Updates)

### Development Login System
- **Environment-based availability**: Backend uses `settings.is_development`, frontend uses `NODE_ENV === "development"`
- **Email prefixing**: Always add "dev:" prefix to development emails to prevent production conflicts
- **Infrastructure reuse**: Development auth MUST use same JWT/NextAuth patterns as production
- **Security isolation**: Development endpoints return 404 in production environments, not 401/403
- **User display names**: Format as "Dev User (original-email)" for easy identification

### NextAuth.js Integration Patterns
- **Conditional providers**: Use array spreading for environment-based providers: `...(isDev ? [DevProvider] : [])`
- **Callback consistency**: Same signIn/jwt/session callbacks must handle both Google OAuth and dev login
- **Token flow**: NextAuth handles OAuth tokens, backend handles JWT API tokens
- **Type safety**: Extend NextAuth types for custom JWT properties

### FastAPI Dependency Injection (CRITICAL)
- **LRU cached factories**: Use `@lru_cache` on dependency factory functions that return dependency functions
- **Constructor injection**: Services take all dependencies in constructor, not as method parameters
- **Repository pattern**: ALL database operations must go through repository classes - no exceptions
- **NO patching in tests**: Use `app.dependency_overrides` with proper mock objects

```python
# ✅ CORRECT Pattern
@lru_cache
def get_auth_service_dependency():
    def dependency(session=Depends(get_session), jwt_manager=Depends(get_jwt_manager)):
        return AuthService(session, jwt_manager)
    return dependency

# Test pattern
app.dependency_overrides[get_auth_service_dependency()] = lambda: mock_service

# ❌ WRONG Pattern - Direct calls or patching
@patch('auth.router.AuthService')  # Breaks DI system
```

## Code Quality Rules (ENFORCED)

### Import Organization (CRITICAL)
- **Top-level ONLY**: ALL imports must be at module level, NEVER inside functions
- **Performance impact**: Imports inside functions hurt performance and violate Python conventions
- **Type annotations**: Always import types needed for proper annotations
- **Test fixtures**: Fixture parameters must be preserved even if they appear unused (`# noqa: ARG002`)

### Repository Pattern (STRICTLY ENFORCED)
- **No direct database queries**: Services MUST use repository methods exclusively
- **No raw SQL deletes**: Use ORM deletion with cascade relationships
- **Single source of truth**: Each entity has one repository handling all its database operations
- **Repository injection**: Services receive repositories through constructor injection

```python
# ✅ CORRECT: ORM deletion with cascade
for existing_set in execution.sets:
    await self.session.delete(existing_set)

# ❌ WRONG: Raw SQL bypasses ORM and cascade rules
await self.session.execute(delete(Set).where(...))
```

## Development Workflow Optimizations

### OpenAPI Generation (Streamlined)
- **Single source of truth**: Generate OpenAPI spec directly to `frontend/openapi.json`
- **No duplication**: Backend should NOT keep local copy of OpenAPI spec
- **Orval configuration**: Point to local `openapi.json`, not `../backend/openapi.json`
- **Task automation**: `task generate-openapi` outputs to `../frontend/openapi.json`
- **Version control**: Add `backend/openapi.json` to `.gitignore` to prevent accidental commits

### Development Authentication Options
1. **Development Login** (Recommended for local dev):
   - Zero setup required - login with any email
   - Available only when `NODE_ENV=development`
   - Creates users with "dev:" prefix
   - Same JWT token flow as production

2. **Google OAuth** (Production-ready):
   - Requires `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`
   - Full production OAuth flow
   - Same as production authentication

## Testing Patterns (Updated)

### FastAPI Testing
- **Dependency overrides**: Use `app.dependency_overrides` instead of patching
- **Service mocking**: Create `Mock(spec=Service)` with `AsyncMock` methods for async operations
- **Environment testing**: Test both development availability AND production blocking
- **Fixture composition**: Use centralized fixtures, avoid duplication across test modules

### Authentication Testing
- **93+ tests passing**: Comprehensive coverage of all authentication scenarios
- **Service layer**: Test user creation, login, error scenarios
- **Router layer**: Test success cases, production blocking, validation
- **Integration**: Test complete flows with real API endpoints

## Security & Environment Patterns

### Environment Isolation
- **Production safety**: Development features must be impossible to access in production
- **Error responses**: Return 404 for disabled endpoints in production (not 401/403)
- **User namespacing**: Development users clearly separated with "dev:" prefix
- **Token consistency**: Same JWT validation regardless of authentication method

### Configuration Management
- **Environment variables**: Use .env files for all configuration
- **Default values**: Provide sensible defaults for development
- **Secret handling**: Never commit secrets, use .env.example for documentation

## User Experience Guidelines

### Development Mode Indicators
- **Clear labeling**: Show "Development Mode" when dev features are active
- **Visual distinction**: Use different button styles (outline) for dev vs production auth
- **Environment detection**: Check both backend and frontend environments consistently

### Error Handling
- **User-friendly messages**: Transform technical errors to readable messages
- **Loading states**: Show proper loading during authentication flows
- **Graceful degradation**: Handle service unavailability gracefully

## Performance & Architecture

### Database Patterns
- **Async throughout**: Use AsyncSession for all database operations
- **Efficient queries**: Use database-level operations for aggregations (99%+ performance improvement)
- **Connection management**: Proper session lifecycle management
- **Migration management**: Use Atlas for all schema changes

### Backend Architecture
- **Functional cohesion**: Organize by domain (auth/, users/, workouts/, exercises/)
- **Service layer**: Business logic separate from data access
- **Error translation**: Convert repository exceptions to appropriate HTTP responses
- **Transaction management**: Handle commits/rollbacks in service layer

## Critical Success Patterns

### Development Workflow
1. **Backend-first**: Implement and test API endpoints before frontend integration
2. **OpenAPI regeneration**: Always regenerate after schema changes with `npm run refresh-api`
3. **Type safety**: Use generated TypeScript types, never manual API calls
4. **Test coverage**: Prioritize service layer, repository layer, then router layer

### Deployment Considerations
- **Environment detection**: Backend uses `ENVIRONMENT` setting, frontend uses `NODE_ENV`
- **Production readiness**: Google OAuth configured and tested
- **Development features**: Properly disabled in production environments
- **Token management**: JWT refresh logic working in both auth methods

This project successfully implements a dual authentication system that provides zero-friction development while maintaining production security through environment-based feature availability.
